// <ownership> ВЛАДЕНИЕ (право собственности):




fn func_1() {
    // Способы взаимодействия переменных и данных: перемещение
    // В Rust многочисленные переменные взаимодействуют с одними и теми же данны­ми по-разному.

    // Это простые значения с известным фиксированным размером, и эти два значения 5 помещаются в СТЕК.
    let x: i32 = 5;
    let mut y: i32 = x; // Происходит копирование данных и создание нового значения 5 в СТЕКЕ
    println!("\n X = {}, Y = {}", x, y);
    y = 10;
    println!("\n X = {}, Y = {}", x, y);

    // Теперь давайте посмотрим на версию с экземпляром типа String:
    // Когда мы присваиваем переменную s1 переменной s2, данные экземпляра типа
    // String копируются, то есть указатель, длина и емкость, которые находятся в стеке.
    // Мы не копируем данные в куче, на которую ссылается указатель:
    // s1 является структурой содержащей указатель, длину и емкость (информация о данных в КУЧЕ)
    let s1: String = String::from("Pasha");

    // В такой ситуации , при выходе из области видимости, оба экземпляра будут пытатся вызвать
    // <drop()> применимо к одной и той же области памяти, что может вызвать критическую ошибку в работе.
    // По этому после копирования указателя в одной области видимости, Rust удалит первый указатель,
    // во избежания ошибки < double free error >
    let s2: String = s1; // Выполняется перемещение, а не копирование данных КУЧИ.
    // println!("\n S1 = {}, S2 = {}", s1, s2); s1 будет удалена после копирования.
    println!("Указатель S2 = {}", s2);

}


fn func_2() {
    // Пути взаимодействия переменных и данных: Clone

    // Если мы все-таки хотим сделать глубокую копию данных String из кучи, а не толь­-
    // ко данных из стека, то можно использовать часто встречающийся метод clone.
    let s1: String = String::from("Pasha Nebrat");
    let s2: String = s1.clone(); // Данные кучи действительно копируются.
    println!("S1 = {}, S2 = {}", s1, s2);
}


fn takes_ownership(var_s: String) {
    println!("Данные кучи <var_s>: {}", var_s);
}


fn makes_copy(var_integer: u32) {
    println!("Данные Стека <var_integer>: {}", var_integer);
}


fn gives_ownership() -> String {
    let var_string = String::from("Return String");
    var_string
}

// takes_and_gives_back возьмет String и вернет String
fn takes_and_gives_back(a_string: String) -> String {
    a_string
}

fn calculate_langth(s: String) -> (String, usize) {
    let length = s.len();
    (s, length)
}

fn main() {
    // Тут литерал "hello" помещается в СТЕК, заранее выделеной памяти
    // Ее размер известен (вычисляется при компиляции) и не может быть изменен после компиляции.
    // Данные Стека во время работы программы уже вычислены при компиляции.
    let s1: &str = "hello ";

    // String создаетсяв КУЧЕ
    // Память будет запрошена у операционной системы во время выполнения программы.
    // объем этой памяти заранее не известен и выдиляется динамически.
    // В Rust нет сборщика мусора и память будет освобождена после выхода программы из
    // облости видимости созданного экземпляра типа String (s2). При выходе из облости видимости 
    // будет не явно вызвана функция <drop()> применительно к <s2>
    {
        let mut s2: String = String::from("hello");
        s2.push_str(", world.");
        println!("\nstr: {}, String: {}", s1, s2);
        // s2.drop()
    };
    // println!("{}", s2); Экземпляра <s2> на этот момент не существует, а выделеная памят освобождена.

    func_1();
    func_2();

    // Владение и функции:
    let var_string: String = String::from("Pasha"); // Входит в облость видимости <main>
    takes_ownership(var_string); // перемещается в функцию, удаляется из владения <main>

    let num_five = 55;  // Входит в облость видимости.
    makes_copy(num_five); // <num_five> копируема (Данные СТЕКА) не будет удалена из владения <main>

    print!("Переменная <num_five> все еще доступна: num_five = {}", num_five);
    // println!("{}", var_string);  error: could not compile `ownership_vladenie


    // <<< Возвращаемые значения и область видимости >>>
    // Передача владения возвращаемых значений:

    // gives_ownership перемещает свое возвращаемое значение в s1
    let s3: String = gives_ownership();

    // s4 перемещается в takes_and_gives_back, которая также перемещает свое возвращаемое значение в s5
    let s4 = String::from("Value String takes and gives back");

    let s5 = takes_and_gives_back(s4);

    println!("\nS3 = {}, S5 = {}", s3, s5);
    // println!("S4 = {}", s4);  s4 отброшена так как была копирована (перемещена) в область функции.


    // С помощью кортежа можно возвращать несколько значений:
    let s6 = String::from("Calculete String Length");
    let (s7, len_string) = calculate_langth(s6);
    println!("S7 = {}, len_string = {}", s7, len_string);


}   // Здесь s5 выходит из области видимости и отбрасывается. s4 выходит
    // из области видимости, но была перемещена, поэтому ничего не происходит.
    // s3 выходит из области и отбрасывается.
