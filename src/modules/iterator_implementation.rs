
// Реализация собственного итератора

// Создадим простой итератор. Итераторы в Rust реализуют трейт Iterator,
// который требует определения метода next().

// Пример простого итератора, который генерирует числа от 1 до 5:


// Определяем структуру `Counter`
struct _Counter {
    count: u32, // Поле для хранения текущего счётчика
}

impl _Counter {
    // Конструктор для создания нового `Counter`
    fn _new() -> Self {
        _Counter { count: 0 } // Возвращаем новый `Counter` с начальным значением `count`
    }
}


// Реализуем трейт `Iterator` для `Counter`
impl Iterator for _Counter {
    // `Item` — это ассоциированный тип, который определяет тип элементов, возвращаемых итератором
    type Item = u32;

    // Метод `next` возвращает следующий элемент в итераторе
    fn next(&mut self) -> Option<Self::Item> {
        self.count += 1; // Увеличиваем счётчик на 1
        if self.count <= 5 {
            // Если счётчик меньше или равен 5, возвращаем его значение
            Some(self.count)
        } else {
            // В противном случае, возвращаем `None`, чтобы сигнализировать конец итерации
            None
        }
    }
}


pub fn _run_iterator() {
    let mut counter: _Counter = _Counter::_new(); // Создаём новый экземпляр `Counter`
    while let Some(num) = counter.next() {
        // Запускаем цикл, пока метод `next` возвращает `Some`
        println!("{}", num); // Печатаем текущее значение счётчика
    }
}

